![SQL](https://usa.bootcampcdn.com/wp-content/uploads/sites/106/2020/03/SQL-Coding-Class-San-Francisco-1.jpeg)
## Теория 
**SQL (Structured Query Language)**
Язык структурированных запросов. Это стандартизированный язык программирования для работы с реляционными базами данных. Он используется для создания, изменения и управления данными в базах данных. SQL предоставляет набор команд и операторов для выполнения различных операций, таких как выборка данных, вставка, обновление и удаление записей, создание и изменение таблиц, управление пользователями и многое другое.

**БД** - база данных - программа для хранения данных

**СУБД - система управления базой данных** - программное обеспечение, которое позволяет управлять, организовывать и обрабатывать данные в базе данных. СУБД предоставляет средства для создания, модификации и удаления данных, а также для выполнения запросов и администрирования базы данных. Содержит пользователей и БД.
Три самые популярные СУБД - MySQL, PostgreSQL, Oracle, Microsoft SQL Server и др, выбор базы данных зависит от требований вашего проекта, масштаба приложения, бюджета и предпочтений разработчиков.

**Реляционные базы данных (РБД) и нереляционные базы данных (NoSQL)** отличаются по своей структуре, модели данных и способу хранения информации. Вот основные отличия между ними:
1) Структура данных:
РБД: В реляционных базах данных данные организованы в таблицы, состоящие из строк и столбцов. Таблицы имеют определенные схемы и связи между ними, определяемые ключами.
NoSQL: В нереляционных базах данных данные хранятся в различных форматах, таких как документы, графы, пары "ключ-значение" и др. Они не обязательно имеют фиксированную схему и связи.
2) Модель данных:
РБД: Реляционные базы данных используют структурированную модель данных, основанную на реляционной алгебре. Данные организованы в таблицы, где каждый столбец имеет определенный тип данных и каждая строка представляет отдельную запись.
NoSQL: Нереляционные базы данных используют различные модели данных, такие как документоориентированная, графовая, столбцовая, ключ-значение и другие. Это позволяет более гибко хранить и организовывать данные, в зависимости от конкретных потребностей приложения.
3) Гибкость схемы данных:
РБД: В реляционных базах данных схема данных часто является строго определенной и предварительно заданной. Изменение схемы может быть сложным процессом и может потребовать изменения структуры таблиц.
NoSQL: Нереляционные базы данных обычно позволяют более гибкую схему данных. Они могут работать с переменной структурой данных, что упрощает добавление, изменение и удаление полей без необходимости изменения всей базы данных.
4) Масштабируемость:
РБД: Реляционные базы данных обычно масштабируются вертикально (путем добавления ресурсов на одном сервере) или горизонтально (путем распределения данных на нескольких серверах). Горизонтальное масштабирование может быть сложным и требует учета согласованности данных.
NoSQL: Нереляционные базы данных обычно лучше масштабируются горизонталь

**IDE** - интегрированная среда разработки, которая предоставляет разработчикам удобную и эффективную среду для разработки программного обеспечения. 
**IDE для СУБД:**

pgAdmin - это популярное графическое средство администрирования для PostgreSQL, одной из ведущих реляционных баз данных. Оно предоставляет удобный и мощный интерфейс для управления и администрирования PostgreSQL-серверами и базами данных.

DBeaver - это универсальное средство администрирования баз данных и клиент SQL, которое поддерживает различные СУБД (системы управления базами данных). Он предоставляет графический интерфейс и набор инструментов для работы с различными типами баз данных.

## Основные SQL запросы с примерами
1. Создание таблицы:
```
CREATE TABLE customers (
  id SERIAL PRIMARY KEY,
  name VARCHAR(50) not null,
  email VARCHAR(50) UNIQUE,
  FOREIGN KEY (name) REFERENCES orders (id)
);
```

> *id - это имя столбца, который будет содержать идентификаторы.*
>
> *serial (/INT) - это тип данных, который обозначает автоинкрементируемое целочисленное значение. В большинстве реляционных баз данных, таких как PostgreSQL, serial является псевдонимом для типа данных INTEGER, который автоматически увеличивается с каждой вставкой новой записи.*
>
> *primary key - это определение столбца как первичного ключа. Первичный ключ используется для уникальной идентификации каждой строки в таблице.*
>
> *not null - при вставке новой записи в таблицу "customers" значения в этих столбцах должны быть указаны и не могут быть пустыми или NULL*
> 
> *UNIQUE - Ограничение UNIQUE гарантирует, что каждое значение в этом столбце будет уникальным, т.е. ни один клиент не сможет иметь одинаковый адрес электронной почты.*
>
> *FOREIGN KEY (name) REFERENCES orders (id) - определение внешнего ключа, который связывает столбец "name" в таблице "customers" со столбцом "id" в таблице "orders". Это означает, что значения в столбце "name" должны существовать в столбце "id" таблицы "orders", обеспечивая ссылочную целостность.*

2. Вставка данных в таблицу:
```
INSERT INTO customers (id, name, email)
VALUES (1, 'John Doe', 'john@example.com');
```
```
INSERT INTO employees (employee_name)
SELECT 'employee' || generate_series(1, 70);
```
 > *Запрос generate_series(1, 70) создает серию чисел от 1 до 70, и для каждого числа выполняется вставка строки в таблицу "employees". Оператор || используется для конкатенации строки "employee" с числом из серии*

3. Выборка всех данных из таблицы:
```
SELECT * FROM customers;
```
4. Выборка данных с условием:
```
SELECT * FROM customers WHERE name = 'John Doe';
```
5. Обновление таблицы
  * Добавление нового столбца в таблицу:
```
  ALTER TABLE users
  ADD age INT;
```
  * Изменение типа данных столбца:
```
  ALTER TABLE users
  ALTER COLUMN age TYPE VARCHAR(10);
  ```
  * Изменение имени столбца:
  ```
  ALTER TABLE users
  RENAME COLUMN age TO age_group;
  ```
  * Удаление столбца из таблицы:
  ```
  ALTER TABLE users
  DROP COLUMN age_group;
  ```
  * Добавление ограничения PRIMARY KEY:
  ```
  ALTER TABLE users
  ADD CONSTRAINT pk_users PRIMARY KEY (id);
  ```
5. Обновление данных в таблице:
```
UPDATE customers SET email = 'johndoe@example.com' WHERE id = 1;
```
6. Удаление таблицы/данных из таблицы:
```
DROP TABLE customers;
```
```
DELETE FROM customers WHERE id = 1;
```

7. Группировка данных с использованием агрегатных функций:
```
SELECT department, AVG(salary) AS average_salary
FROM employees
GROUP BY department;
```
8. Объединение данных из нескольких таблиц:
```
SELECT customers.name, orders.order_date
FROM customers
JOIN orders ON customers.id = orders.customer_id;
```
9. Использование условий с оператором IN:
```
SELECT * FROM products WHERE category IN ('Electronics', 'Clothing');
```
10. Сортировка данных по возрастанию или убыванию:
```
SELECT * FROM customers ORDER BY name ASC; -- Сортировка по возрастанию
SELECT * FROM customers ORDER BY name DESC; -- Сортировка по убыванию
```
11. Использование оператора LIKE для поиска по шаблону:
```
SELECT * FROM customers WHERE name LIKE 'J%'; -- Находит все имена, начинающиеся с 'J'
SELECT * FROM customers WHERE email LIKE '%example.com'; -- Находит все email, заканчивающиеся на 'example.com'
```
12. Использование агрегатных функций для вычисления сумм, средних значений и других статистических показателей:
```
SELECT COUNT(*) AS total_customers FROM customers; -- Вычисление общего количества записей в таблице
SELECT AVG(salary) AS average_salary FROM employees; -- Вычисление средней зарплаты
SELECT MAX(price) AS max_price FROM products; -- Вычисление максимальной цены
```
13. Использование оператора BETWEEN для выборки данных в заданном диапазоне:
```
SELECT * FROM products WHERE price BETWEEN 10 AND 50; -- Выбирает все продукты с ценой от 10 до 50
SELECT * FROM orders WHERE order_date BETWEEN '2022-01-01' AND '2022-12-31'; -- Выбирает все заказы в определенном периоде
```
14. Использование функций для обработки строк и дат:
```
SELECT CONCAT(first_name, ' ', last_name) AS full_name FROM employees; -- Объединяет значения двух столбцов в одну строку
SELECT DATE_FORMAT(order_date, '%Y-%m-%d') AS formatted_date FROM orders; -- Форматирует дату в определенном формате
```
15. Использование подзапросов для выполнения вложенных запросов:
```
SELECT * FROM products WHERE category_id IN (SELECT id FROM categories WHERE name = 'Electronics'); -- Выбирает все продукты из категории 'Electronics'
SELECT * FROM employees WHERE department_id = (SELECT id FROM departments WHERE name = 'Sales'); -- Выбирает всех сотрудников из отдела 'Sales'
```
16. Использование оператора DISTINCT для выборки уникальных значений:
```
SELECT DISTINCT category FROM products; -- Возвращает список уникальных категорий продуктов
SELECT DISTINCT city FROM customers; -- Возвращает список уникальных городов клиентов
```
17. Использование оператора JOIN для объединения данных из нескольких таблиц:
```
SELECT customers.name, orders.order_date
FROM customers
JOIN orders ON customers.id = orders.customer_id;
```
18. Использование условий NULL для проверки наличия или отсутствия значений:
```
SELECT * FROM products WHERE description IS NULL; -- Выбирает продукты, у которых нет описания
SELECT * FROM customers WHERE phone_number IS NOT NULL; -- Выбирает клиентов с указанным номером телефона
```
19. Использование оператора IN для выборки данных из списка значений:
```
SELECT * FROM products WHERE category IN ('Electronics', 'Clothing'); -- Выбирает продукты из категорий 'Electronics' и 'Clothing'
SELECT * FROM orders WHERE customer_id IN (1, 2, 3); -- Выбирает заказы, принадлежащие клиентам с ID 1, 2 и 3
```
20. Использование операторов AND и OR для создания составных условий:
```
SELECT * FROM products WHERE price > 50 AND category = 'Electronics'; -- Выбирает продукты из категории 'Electronics' с ценой выше 50
SELECT * FROM customers WHERE city = 'New York' OR city = 'Los Angeles'; -- Выбирает клиентов из городов 'New York' или 'Los Angeles'
```
21. Использование оператора LIMIT для ограничения количества возвращаемых строк:
```
SELECT * FROM products LIMIT 10; -- Возвращает только первые 10 продуктов из таблицы
SELECT * FROM orders LIMIT 100, 50; -- Возвращает 50 заказов, начиная со 101-го заказа
```
22. Использование оператора UNION для объединения таблиц вертикально:
```
SELECT customer_name, email
FROM Customers
UNION
SELECT supplier_name, email
FROM Suppliers;
```

https://www.sql-ex.ru/ - сайт для отработки написания запросов
